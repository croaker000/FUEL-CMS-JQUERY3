/*!
* jQuery Form Plugin
* version: 4.3.0.1
*
* FoM: Manually updated for https://github.com/jquery-form/form/pull/599/files
*
* Requires jQuery v1.7.2 or later
* Project repository: https://github.com/jquery-form/form
* Copyright 2017 Kevin Morris
* Copyright 2006 M. Alsup
* Dual licensed under the LGPL-2.1+ or MIT licenses
* https://github.com/jquery-form/form#license
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*/
/* global ActiveXObject */
/* eslint-disable */
(function (factory) {
if (typeof define === 'function' && define.amd) {
// AMD. Register as an anonymous module.
define(['jquery'], factory);
} else if (typeof module === 'object' && module.exports) {
// Node/CommonJS
module.exports = function( root, jQuery ) {
if (typeof jQuery === 'undefined') {
// require('jQuery') returns a factory that requires window to build a jQuery instance, we normalize how we use modules
// that require this pattern but the window provided is a noop if it's defined (how jquery works)
if (typeof window !== 'undefined') {
jQuery = require('jquery');
}
else {
jQuery = require('jquery')(root);
}
}
factory(jQuery);
return jQuery;
};
} else {
// Browser globals
factory(jQuery);
}
}(function ($) {
/* eslint-enable */
'use strict';
/*
Usage Note:
-----------
Do not use both ajaxSubmit and ajaxForm on the same form. These
functions are mutually exclusive. Use ajaxSubmit if you want
to bind your own submit handler to the form. For example,
$(document).ready(function() {
$('#myForm').on('submit', function(e) {
e.preventDefault(); // <-- important
$(this).ajaxSubmit({
target: '#output'
});
});
});
Use ajaxForm when you want the plugin to manage all the event binding
for you. For example,
$(document).ready(function() {
$('#myForm').ajaxForm({
target: '#output'
});
});
You can also use ajaxForm with delegation (requires jQuery v1.7+), so the
form does not have to exist when you invoke ajaxForm:
$('#myForm').ajaxForm({
delegation: true,
target: '#output'
});
When using ajaxForm, the ajaxSubmit function will be invoked for you
at the appropriate time.
*/
var rCRLF = /\r?\n/g;
/**
* Feature detection
*/
var feature = {};
feature.fileapi = $('<input type="file">').get(0).files !== undefined;
feature.formdata = (typeof window.FormData !== 'undefined');
var hasProp = !!$.fn.prop;
// attr2 uses prop when it can but checks the return type for
// an expected string. This accounts for the case where a form
// contains inputs with names like "action" or "method"; in those
// cases "prop" returns the element
$.fn.attr2 = function() {
if (!hasProp) {
return this.attr.apply(this, arguments);
}
var val = this.prop.apply(this, arguments);
if ((val && val.jquery) || typeof val === 'string') {
return val;
}
return this.attr.apply(this, arguments);
};
/**
* ajaxSubmit() provides a mechanism for immediately submitting
* an HTML form using AJAX.
*
* @param{object|string}optionsjquery.form.js parameters or custom url for submission
* @param{object}dataextraData
* @param{string}dataTypeajax dataType
* @param{function}onSuccessajax success callback function
*/
$.fn.ajaxSubmit = function(options, data, dataType, onSuccess) {
// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
if (!this.length) {
log('ajaxSubmit: skipping submit process - no element selected');
return this;
}
/* eslint consistent-this: ["error", "$form"] */
var method, action, url, isMsie, iframeSrc, $form = this;
if (typeof options === 'function') {
options = {success: options};
} else if (typeof options === 'string' || (options === false && arguments.length > 0)) {
options = {
'url'      : options,
'data'     : data,
'dataType' : dataType
};
if (typeof onSuccess === 'function') {
options.success = onSuccess;
}
} else if (typeof options === 'undefined') {
options = {};
}
method = options.method || options.type || this.attr2('method');
action = options.url || this.attr2('action');
//url = (typeof action === 'string') ? $.trim(action) : '';
url = (typeof action === 'string') ? action.trim() : '';
url = url || window.location.href || '';
if (url) {
// clean url (don't include hash vaue)
url = (url.match(/^([^#]+)/) || [])[1];
}
// IE requires javascript:false in https, but this breaks chrome >83 and goes against spec.
// Instead of using javascript:false always, let's only apply it for IE.
isMsie = /(MSIE|Trident)/.test(navigator.userAgent || '');
iframeSrc = (isMsie && /^https/i.test(window.location.href || '')) ? 'javascript:false' : 'about:blank'; // eslint-disable-line no-script-url
options = $.extend(true, {
url       : url,
success   : $.ajaxSettings.success,
type      : method || $.ajaxSettings.type,
iframeSrc : iframeSrc
}, options);
// hook for manipulating the form data before it is extracted;
// convenient for use with rich editors like tinyMCE or FCKEditor
var veto = {};
this.trigger('form-pre-serialize', [this, options, veto]);
if (veto.veto) {
log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
return this;
}
// provide opportunity to alter form data before it is serialized
if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
log('ajaxSubmit: submit aborted via beforeSerialize callback');
return this;
}
var traditional = options.traditional;
if (typeof traditional === 'undefined') {
traditional = $.ajaxSettings.traditional;
}
var elements = [];
var qx, a = this.formToArray(options.semantic, elements, options.filtering);
if (options.data) {
//var optionsData = $.isFunction(options.data) ? options.data(a) : options.data;
var optionsData = typeof options.data === 'function' ? options.data(a) : options.data;
options.extraData = optionsData;
qx = $.param(optionsData, traditional);
}
// give pre-submit callback an opportunity to abort the submit
if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
log('ajaxSubmit: submit aborted via beforeSubmit callback');
return this;
}
// fire vetoable 'validate' event
this.trigger('form-submit-validate', [a, this, options, veto]);
if (veto.veto) {
log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
return this;
}
var q = $.param(a, traditional);
if (qx) {
q = (q ? (q + '&' + qx) : qx);
}
if (options.type.toUpperCase() === 'GET') {
options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
options.data = null;// data is null for 'get'
} else {
options.data = q;// data is the query string for 'post'
}
var callbacks = [];
if (options.resetForm) {
callbacks.push(function() {
$form.resetForm();
});
}
if (options.clearForm) {
callbacks.push(function() {
$form.clearForm(options.includeHidden);
});
}
// perform a load on the target only if dataType is not provided
if (!options.dataType && options.target) {
var oldSuccess = options.success || function(){};
callbacks.push(function(data, textStatus, jqXHR) {
var successArguments = arguments,
fn = options.replaceTarget ? 'replaceWith' : 'html';
// Validate `data` through `HTML encoding` when passed `data` is passed
// to `html()`, as suggested in https://github.com/jquery-form/form/issues/464
fn == 'html' ? data = $.parseHTML($("<div>").text(data).html()) : '';
$(options.target)[fn](data).each(function(){
oldSuccess.apply(this, successArguments);
});
});
} else if (options.success) {
//if ($.isArray(options.success)) {
if (Array.isArray(options.success)) {
$.merge(callbacks, options.success);
} else {
callbacks.push(options.success);
}
}
options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
var context = options.context || this;// jQuery 1.4+ supports scope context
for (var i = 0, max = callbacks.length; i < max; i++) {
callbacks[i].apply(context, [data, status, xhr || $form, $form]);
}
};
if (options.error) {
var oldError = options.error;
options.error = function(xhr, status, error) {
var context = options.context || this;
oldError.apply(context, [xhr, status, error, $form]);
};
}
if (options.complete) {
var oldComplete = options.complete;
options.complete = function(xhr, status) {
var context = options.context || this;
oldComplete.apply(context, [xhr, status, $form]);
};
}
// are there files to upload?
// [value] (issue #113), also see comment:
// https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219
var fileInputs = $('input[type=file]:enabled', this).filter(function() {
return $(this).val() !== '';
});
var hasFileInputs = fileInputs.length > 0;
var mp = 'multipart/form-data';
var multipart = ($form.attr('enctype') === mp || $form.attr('encoding') === mp);
var fileAPI = feature.fileapi && feature.formdata;
log('fileAPI :' + fileAPI);
var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;
var jqxhr;
// options.iframe allows user to force iframe mode
// 06-NOV-09: now defaulting to iframe mode if file input is detected
if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
// hack to fix Safari hang (thanks to Tim Molendijk for this)
// see: http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
if (options.closeKeepAlive) {
$.get(options.closeKeepAlive, function() {
jqxhr = fileUploadIframe(a);
});
} else {
jqxhr = fileUploadIframe(a);
}
} else if ((hasFileInputs || multipart) && fileAPI) {
jqxhr = fileUploadXhr(a);
} else {
jqxhr = $.ajax(options);
}
$form.removeData('jqxhr').data('jqxhr', jqxhr);
// clear element array
for (var k = 0; k < elements.length; k++) {
elements[k] = null;
}
// fire 'notify' event
this.trigger('form-submit-notify', [this, options]);
return this;
// utility fn for deep serialization
function deepSerialize(extraData) {
var serialized = $.param(extraData, options.traditional).split('&');
var len = serialized.length;
var result = [];
var i, part;
for (i = 0; i < len; i++) {
// #252; undo param space replacement
serialized[i] = serialized[i].replace(/\+/g, ' ');
part = serialized[i].split('=');
// #278; use array instead of object storage, favoring array serializations
result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);
}
return result;
}
// XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
function fileUploadXhr(a) {
var formdata = new FormData();
for (var i = 0; i < a.length; i++) {
formdata.append(a[i].name, a[i].value);
}
if (options.extraData) {
var serializedData = deepSerialize(options.extraData);
for (i = 0; i < serializedData.length; i++) {
if (serializedData[i]) {
formdata.append(serializedData[i][0], serializedData[i][1]);
}
}
}
options.data = null;
var s = $.extend(true, {}, $.ajaxSettings, options, {
contentType : false,
processData : false,
cache       : false,
type        : method || 'POST'
});
if (options.uploadProgress) {
// workaround because jqXHR does not expose upload property
s.xhr = function() {
var xhr = $.ajaxSettings.xhr();
if (xhr.upload) {
xhr.upload.addEventListener('progress', function(event) {
var percent = 0;
var position = event.loaded || event.position;/* event.position is deprecated */
var total = event.total;
if (event.lengthComputable) {
percent = Math.ceil(position / total * 100);
}
options.uploadProgress(event, position, total, percent);
}, false);
}
return xhr;
};
}
s.data = null;
var beforeSend = s.beforeSend;
s.beforeSend = function(xhr, o) {
// Send FormData() provided by user
if (options.formData) {
o.data = options.formData;
} else {
o.data = formdata;
}
if (beforeSend) {
beforeSend.call(this, xhr, o);
}
};
return $.ajax(s);
}
// private function for handling file uploads (hat tip to YAHOO!)
function fileUploadIframe(a) {
var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
var deferred = $.Deferred();
// #341
deferred.abort = function(status) {
xhr.abort(status);
};
if (a) {
// ensure that every serialized input is still enabled
for (i = 0; i < elements.length; i++) {
el = $(elements[i]);
if (hasProp) {
el.prop('disabled', false);
} else {
//el.removeAttr('disabled');
el.prop('disabled',false);
}
}
}
s = $.extend(true, {}, $.ajaxSettings, options);
s.context = s.context || s;
id = 'jqFormIO' + new Date().getTime();
var ownerDocument = form.ownerDocument;
var $body = $form.closest('body');
if (s.iframeTarget) {
$io = $(s.iframeTarget, ownerDocument);
n = $io.attr2('name');
if (!n) {
$io.attr2('name', id);
} else {
id = n;
}
} else {
//$io = $('<iframe name="' + id + '" src="' + s.iframeSrc + '" />', ownerDocument);
$io = $('<iframe name="' + id + '" src="' + s.iframeSrc + '" ></iframe>', ownerDocument);
$io.css({position: 'absolute', top: '-1000px', left: '-1000px'});
}
io = $io[0];
xhr = { // mock object
aborted               : 0,
responseText          : null,
responseXML           : null,
status                : 0,
statusText            : 'n/a',
getAllResponseHeaders : function() {},
getResponseHeader     : function() {},
setRequestHeader      : function() {},
abort                 : function(status) {
var e = (status === 'timeout' ? 'timeout' : 'aborted');
log('aborting upload... ' + e);
this.aborted = 1;
try { // #214, #257
if (io.contentWindow.document.execCommand) {
io.contentWindow.document.execCommand('Stop');
}
} catch (ignore) {}
$io.attr('src', s.iframeSrc); // abort op in progress
xhr.error = e;
if (s.error) {
s.error.call(s.context, xhr, e, status);
}
if (g) {
$.event.trigger('ajaxError', [xhr, s, e]);
}
if (s.complete) {
s.complete.call(s.context, xhr, e);
}
}
};
g = s.global;
// trigger ajax global events so that activity/block indicators work like normal
if (g && $.active++ === 0) {
$.event.trigger('ajaxStart');
}
if (g) {
$.event.trigger('ajaxSend', [xhr, s]);
}
if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
if (s.global) {
$.active--;
}
deferred.reject();
return deferred;
}
if (xhr.aborted) {
deferred.reject();
return deferred;
}
// add submitting element to data if we know it
sub = form.clk;
if (sub) {
n = sub.name;
if (n && !sub.disabled) {
s.extraData = s.extraData || {};
s.extraData[n] = sub.value;
if (sub.type === 'image') {
s.extraData[n + '.x'] = form.clk_x;
s.extraData[n + '.y'] = form.clk_y;
}
}
}
var CLIENT_TIMEOUT_ABORT = 1;
var SERVER_ABORT = 2;
function getDoc(frame) {
/* it looks like contentWindow or contentDocument do not
* carry the protocol property in ie8, when running under ssl
* frame.document is the only valid response document, since
* the protocol is know but not on the other two objects. strange?
* "Same origin policy" http://en.wikipedia.org/wiki/Same_origin_policy
*/
var doc = null;
// IE8 cascading access check
try {
if (frame.contentWindow) {
doc = frame.contentWindow.document;
}
} catch (err) {
// IE8 access denied under ssl & missing protocol
log('cannot get iframe.contentWindow document: ' + err);
}
if (doc) { // successful getting content
return doc;
}
try { // simply checking may throw in ie8 under ssl or mismatched protocol
doc = frame.contentDocument ? frame.contentDocument : frame.document;
} catch (err) {
// last attempt
log('cannot get iframe.contentDocument: ' + err);
doc = frame.document;
}
return doc;
}
// Rails CSRF hack (thanks to Yvan Barthelemy)
var csrf_token = $('meta[name=csrf-token]').attr('content');
var csrf_param = $('meta[name=csrf-param]').attr('content');
if (csrf_param && csrf_token) {
s.extraData = s.extraData || {};
s.extraData[csrf_param] = csrf_token;
}
// take a breath so that pending repaints get some cpu time before the upload starts
function doSubmit() {
// make sure form attrs are set
var t = $form.attr2('target'),
a = $form.attr2('action'),
mp = 'multipart/form-data',
et = $form.attr('enctype') || $form.attr('encoding') || mp;
// update form attrs in IE friendly way
form.setAttribute('target', id);
if (!method || /post/i.test(method)) {
form.setAttribute('method', 'POST');
}
if (a !== s.url) {
form.setAttribute('action', s.url);
}
// ie borks in some cases when setting encoding
if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {
$form.attr({
encoding : 'multipart/form-data',
enctype  : 'multipart/form-data'
});
}
// support timout
if (s.timeout) {
timeoutHandle = setTimeout(function() {
timedOut = true; cb(CLIENT_TIMEOUT_ABORT);
}, s.timeout);
}
// look for server aborts
function checkState() {
try {
var state = getDoc(io).readyState;
log('state = ' + state);
if (state && state.toLowerCase() === 'uninitialized') {
setTimeout(checkState, 50);
}
} catch (e) {
log('Server abort: ', e, ' (', e.name, ')');
cb(SERVER_ABORT);// eslint-disable-line callback-return
if (timeoutHandle) {
clearTimeout(timeoutHandle);
}
timeoutHandle = undefined;
}
}
// add "extra" data to form if provided in options
var extraInputs = [];
try {
if (s.extraData) {
for (var n in s.extraData) {
if (s.extraData.hasOwnProperty(n)) {
// if using the $.param format that allows for multiple values with the same name
if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {
extraInputs.push(
$('<input type="hidden" name="' + s.extraData[n].name + '">', ownerDocument).val(s.extraData[n].value)
.appendTo(form)[0]);
} else {
extraInputs.push(
$('<input type="hidden" name="' + n + '">', ownerDocument).val(s.extraData[n])
.appendTo(form)[0]);
}
}
}
}
if (!s.iframeTarget) {
// add iframe to doc and submit the form
$io.appendTo($body);
}
if (io.attachEvent) {
io.attachEvent('onload', cb);
} else {
io.addEventListener('load', cb, false);
}
setTimeout(checkState, 15);
try {
form.trigger('submit');
} catch (err) {
// just in case form has element with name/id of 'submit'
var submitFn = document.createElement('form').submit;
submitFn.apply(form);
}
} finally {
// reset attrs and remove "extra" input elements
form.setAttribute('action', a);
form.setAttribute('enctype', et); // #380
if (t) {
form.setAttribute('target', t);
} else {
$form.removeAttr('target');
}
$(extraInputs).remove();
}
}
if (s.forceSync) {
doSubmit();
} else {
setTimeout(doSubmit, 10); // this lets dom updates render
}
var data, doc, domCheckCount = 50, callbackProcessed;
function cb(e) {
if (xhr.aborted || callbackProcessed) {
return;
}
doc = getDoc(io);
if (!doc) {
log('cannot access response document');
e = SERVER_ABORT;
}
if (e === CLIENT_TIMEOUT_ABORT && xhr) {
xhr.abort('timeout');
deferred.reject(xhr, 'timeout');
return;
}
if (e === SERVER_ABORT && xhr) {
xhr.abort('server abort');
deferred.reject(xhr, 'error', 'server abort');
return;
}
if (!doc || doc.location.href === s.iframeSrc) {
// response not received yet
if (!timedOut) {
return;
}
}
if (io.detachEvent) {
io.detachEvent('onload', cb);
} else {
io.removeEventListener('load', cb, false);
}
var status = 'success', errMsg;
try {
if (timedOut) {
throw 'timeout';
}
var isXml = s.dataType === 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
log('isXml=' + isXml);
if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {
if (--domCheckCount) {
// in some browsers (Opera) the iframe DOM is not always traversable when
// the onload callback fires, so we loop a bit to accommodate
log('requeing onLoad callback, DOM not available');
setTimeout(cb, 250);
return;
}
// let this fall through because server response could be an empty document
// log('Could not access iframe DOM after mutiple tries.');
// throw 'DOMException: not available';
}
// log('response detected');
var docRoot = doc.body ? doc.body : doc.documentElement;
xhr.responseText = docRoot ? docRoot.innerHTML : null;
xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
if (isXml) {
s.dataType = 'xml';
}
xhr.getResponseHeader = function(header){
var headers = {'content-type': s.dataType};
return headers[header.toLowerCase()];
};
// support for XHR 'status' & 'statusText' emulation :
if (docRoot) {
xhr.status = Number(docRoot.getAttribute('status')) || xhr.status;
xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
}
var dt = (s.dataType || '').toLowerCase();
var scr = /(json|script|text)/.test(dt);
if (scr || s.textarea) {
// see if user embedded response in textarea
var ta = doc.getElementsByTagName('textarea')[0];
if (ta) {
xhr.responseText = ta.value;
// support for XHR 'status' & 'statusText' emulation :
xhr.status = Number(ta.getAttribute('status')) || xhr.status;
xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
} else if (scr) {
// account for browsers injecting pre around json response
var pre = doc.getElementsByTagName('pre')[0];
var b = doc.getElementsByTagName('body')[0];
if (pre) {
xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
} else if (b) {
xhr.responseText = b.textContent ? b.textContent : b.innerText;
}
}
} else if (dt === 'xml' && !xhr.responseXML && xhr.responseText) {
xhr.responseXML = toXml(xhr.responseText);// eslint-disable-line no-use-before-define
}
try {
data = httpData(xhr, dt, s);// eslint-disable-line no-use-before-define
} catch (err) {
status = 'parsererror';
xhr.error = errMsg = (err || status);
}
} catch (err) {
log('error caught: ', err);
status = 'error';
xhr.error = errMsg = (err || status);
}
if (xhr.aborted) {
log('upload aborted');
status = null;
}
if (xhr.status) { // we've set xhr.status
status = ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) ? 'success' : 'error';
}
// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
if (status === 'success') {
if (s.success) {
s.success.call(s.context, data, 'success', xhr);
}
deferred.resolve(xhr.responseText, 'success', xhr);
if (g) {
$.event.trigger('ajaxSuccess', [xhr, s]);
}
} else if (status) {
if (typeof errMsg === 'undefined') {
errMsg = xhr.statusText;
}
if (s.error) {
s.error.call(s.context, xhr, status, errMsg);
}
deferred.reject(xhr, 'error', errMsg);
if (g) {
$.event.trigger('ajaxError', [xhr, s, errMsg]);
}
}
if (g) {
$.event.trigger('ajaxComplete', [xhr, s]);
}
if (g && !--$.active) {
$.event.trigger('ajaxStop');
}
if (s.complete) {
s.complete.call(s.context, xhr, status);
}
callbackProcessed = true;
if (s.timeout) {
clearTimeout(timeoutHandle);
}
// clean up
setTimeout(function() {
if (!s.iframeTarget) {
$io.remove();
} else { // adding else to clean up existing iframe response.
$io.attr('src', s.iframeSrc);
}
xhr.responseXML = null;
}, 100);
}
var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
if (window.ActiveXObject) {
doc = new ActiveXObject('Microsoft.XMLDOM');
doc.async = 'false';
doc.loadXML(s);
} else {
doc = (new DOMParser()).parseFromString(s, 'text/xml');
}
return (doc && doc.documentElement && doc.documentElement.nodeName !== 'parsererror') ? doc : null;
};
var parseJSON = $.parseJSON || function(s) {
// /* jslint evil:true */
// return window['eval']('(' + s + ')');// eslint-disable-line dot-notation
// Arise an error resolvable including jquery instead of making a new function using unsanitized inputs
window.console.error('jquery.parseJSON is undefined');
return null;
};
var httpData = function(xhr, type, s) { // mostly lifted from jq1.4.4
var ct = xhr.getResponseHeader('content-type') || '',
xml = ((type === 'xml' || !type) && ct.indexOf('xml') >= 0),
data = xml ? xhr.responseXML : xhr.responseText;
if (xml && data.documentElement.nodeName === 'parsererror') {
if ($.error) {
$.error('parsererror');
}
}
if (s && s.dataFilter) {
data = s.dataFilter(data, type);
}
if (typeof data === 'string') {
if ((type === 'json' || !type) && ct.indexOf('json') >= 0) {
data = parseJSON(data);
} else if ((type === 'script' || !type) && ct.indexOf('javascript') >= 0) {
$.globalEval(data);
}
}
return data;
};
return deferred;
}
};
/**
* ajaxForm() provides a mechanism for fully automating form submission.
*
* The advantages of using this method instead of ajaxSubmit() are:
*
* 1: This method will include coordinates for <input type="image"> elements (if the element
*is used to submit the form).
* 2. This method will include the submit element's name/value data (for the element that was
*used to submit the form).
* 3. This method binds the submit() method to the form for you.
*
* The options argument for ajaxForm works exactly as it does for ajaxSubmit. ajaxForm merely
* passes the options argument along after properly binding events for submit elements and
* the form itself.
*/
$.fn.ajaxForm = function(options, data, dataType, onSuccess) {
if (typeof options === 'string' || (options === false && arguments.length > 0)) {
options = {
'url'      : options,
'data'     : data,
'dataType' : dataType
};
if (typeof onSuccess === 'function') {
options.success = onSuccess;
}
}
options = options || {};
//options.delegation = options.delegation && $.isFunction($.fn.on);
options.delegation = options.delegation && typeof $.fn.on === 'function';
// in jQuery 1.3+ we can fix mistakes with the ready state
if (!options.delegation && this.length === 0) {
var o = {s: this.selector, c: this.context};
if (!$.isReady && o.s) {
log('DOM not ready, queuing ajaxForm');
$(function() {
$(o.s, o.c).ajaxForm(options);
});
return this;
}
// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
return this;
}
if (options.delegation) {
$(document)
.off('submit.form-plugin', this.selector, doAjaxSubmit)
.off('click.form-plugin', this.selector, captureSubmittingElement)
.on('submit.form-plugin', this.selector, options, doAjaxSubmit)
.on('click.form-plugin', this.selector, options, captureSubmittingElement);
return this;
}
if (options.beforeFormUnbind) {
options.beforeFormUnbind(this, options);
}
return this.ajaxFormUnbind()
.on('submit.form-plugin', options, doAjaxSubmit)
.on('click.form-plugin', options, captureSubmittingElement);
};
// private event handlers
function doAjaxSubmit(e) {
/* jshint validthis:true */
var options = e.data;
if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
e.preventDefault();
$(e.target).closest('form').ajaxSubmit(options); // #365
}
}
function captureSubmittingElement(e) {
/* jshint validthis:true */
var target = e.target;
var $el = $(target);
if (!$el.is('[type=submit],[type=image]')) {
// is this a child element of the submit el?  (ex: a span within a button)
var t = $el.closest('[type=submit]');
if (t.length === 0) {
return;
}
target = t[0];
}
var form = target.form;
form.clk = target;
if (target.type === 'image') {
if (typeof e.offsetX !== 'undefined') {
form.clk_x = e.offsetX;
form.clk_y = e.offsetY;
} else if (typeof $.fn.offset === 'function') {
var offset = $el.offset();
form.clk_x = e.pageX - offset.left;
form.clk_y = e.pageY - offset.top;
} else {
form.clk_x = e.pageX - target.offsetLeft;
form.clk_y = e.pageY - target.offsetTop;
}
}
// clear form vars
setTimeout(function() {
form.clk = form.clk_x = form.clk_y = null;
}, 100);
}
// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
return this.off('submit.form-plugin click.form-plugin');
};
/**
* formToArray() gathers form element data into an array of objects that can
* be passed to any of the following ajax functions: $.get, $.post, or load.
* Each object in the array has both a 'name' and 'value' property. An example of
* an array for a simple login form might be:
*
* [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
*
* It is this array that is passed to pre-submit callback functions provided to the
* ajaxSubmit() and ajaxForm() methods.
*/
$.fn.formToArray = function(semantic, elements, filtering) {
var a = [];
if (this.length === 0) {
return a;
}
var form = this[0];
var formId = this.attr('id');
var els = (semantic || typeof form.elements === 'undefined') ? form.getElementsByTagName('*') : form.elements;
var els2;
if (els) {
els = $.makeArray(els); // convert to standard array
}
// #386; account for inputs outside the form which use the 'form' attribute
// FinesseRus: in non-IE browsers outside fields are already included in form.elements.
if (formId && (semantic || /(Edge|Trident)\//.test(navigator.userAgent))) {
els2 = $(':input[form="' + formId + '"]').get(); // hat tip @thet
if (els2.length) {
els = (els || []).concat(els2);
}
}
if (!els || !els.length) {
return a;
}
//if ($.isFunction(filtering)) {
if (typeof filtering === 'function') {
els = $.map(els, filtering);
}
var i, j, n, v, el, max, jmax;
for (i = 0, max = els.length; i < max; i++) {
el = els[i];
n = el.name;
if (!n || el.disabled) {
continue;
}
if (semantic && form.clk && el.type === 'image') {
// handle image inputs on the fly when semantic == true
if (form.clk === el) {
a.push({name: n, value: $(el).val(), type: el.type});
a.push({name: n + '.x', value: form.clk_x}, {name: n + '.y', value: form.clk_y});
}
continue;
}
v = $.fieldValue(el, true);
if (v && v.constructor === Array) {
if (elements) {
elements.push(el);
}
for (j = 0, jmax = v.length; j < jmax; j++) {
a.push({name: n, value: v[j]});
}
} else if (feature.fileapi && el.type === 'file') {
if (elements) {
elements.push(el);
}
var files = el.files;
if (files.length) {
for (j = 0; j < files.length; j++) {
a.push({name: n, value: files[j], type: el.type});
}
} else {
// #180
a.push({name: n, value: '', type: el.type});
}
} else if (v !== null && typeof v !== 'undefined') {
if (elements) {
elements.push(el);
}
a.push({name: n, value: v, type: el.type, required: el.required});
}
}
if (!semantic && form.clk) {
// input type=='image' are not found in elements array! handle it here
var $input = $(form.clk), input = $input[0];
n = input.name;
if (n && !input.disabled && input.type === 'image') {
a.push({name: n, value: $input.val()});
a.push({name: n + '.x', value: form.clk_x}, {name: n + '.y', value: form.clk_y});
}
}
return a;
};
/**
* Serializes form data into a 'submittable' string. This method will return a string
* in the format: name1=value1&amp;name2=value2
*/
$.fn.formSerialize = function(semantic) {
// hand off to jQuery.param for proper encoding
return $.param(this.formToArray(semantic));
};
/**
* Serializes all field elements in the jQuery object into a query string.
* This method will return a string in the format: name1=value1&amp;name2=value2
*/
$.fn.fieldSerialize = function(successful) {
var a = [];
this.each(function() {
var n = this.name;
if (!n) {
return;
}
var v = $.fieldValue(this, successful);
if (v && v.constructor === Array) {
for (var i = 0, max = v.length; i < max; i++) {
a.push({name: n, value: v[i]});
}
} else if (v !== null && typeof v !== 'undefined') {
a.push({name: this.name, value: v});
}
});
// hand off to jQuery.param for proper encoding
return $.param(a);
};
/**
* Returns the value(s) of the element in the matched set. For example, consider the following form:
*
*<form><fieldset>
*<input name="A" type="text">
*<input name="A" type="text">
*<input name="B" type="checkbox" value="B1">
*<input name="B" type="checkbox" value="B2">
*<input name="C" type="radio" value="C1">
*<input name="C" type="radio" value="C2">
*</fieldset></form>
*
*var v = $('input[type=text]').fieldValue();
*// if no values are entered into the text inputs
*v === ['','']
*// if values entered into the text inputs are 'foo' and 'bar'
*v === ['foo','bar']
*
*var v = $('input[type=checkbox]').fieldValue();
*// if neither checkbox is checked
*v === undefined
*// if both checkboxes are checked
*v === ['B1', 'B2']
*
*var v = $('input[type=radio]').fieldValue();
*// if neither radio is checked
*v === undefined
*// if first radio is checked
*v === ['C1']
*
* The successful argument controls whether or not the field element must be 'successful'
* (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
* The default value of the successful argument is true. If this value is false the value(s)
* for each element is returned.
*
* Note: This method *always* returns an array. If no valid value can be determined the
*array will be empty, otherwise it will contain one or more values.
*/
$.fn.fieldValue = function(successful) {
for (var val = [], i = 0, max = this.length; i < max; i++) {
var el = this[i];
var v = $.fieldValue(el, successful);
if (v === null || typeof v === 'undefined' || (v.constructor === Array && !v.length)) {
continue;
}
if (v.constructor === Array) {
$.merge(val, v);
} else {
val.push(v);
}
}
return val;
};
/**
* Returns the value of the field element.
*/
$.fieldValue = function(el, successful) {
var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
if (typeof successful === 'undefined') {
successful = true;
}
/* eslint-disable no-mixed-operators */
if (successful && (!n || el.disabled || t === 'reset' || t === 'button' ||
(t === 'checkbox' || t === 'radio') && !el.checked ||
(t === 'submit' || t === 'image') && el.form && el.form.clk !== el ||
tag === 'select' && el.selectedIndex === -1)) {
/* eslint-enable no-mixed-operators */
return null;
}
if (tag === 'select') {
var index = el.selectedIndex;
if (index < 0) {
return null;
}
var a = [], ops = el.options;
var one = (t === 'select-one');
var max = (one ? index + 1 : ops.length);
for (var i = (one ? index : 0); i < max; i++) {
var op = ops[i];
if (op.selected && !op.disabled) {
var v = op.value;
if (!v) { // extra pain for IE...
v = (op.attributes && op.attributes.value && !(op.attributes.value.specified)) ? op.text : op.value;
}
if (one) {
return v;
}
a.push(v);
}
}
return a;
}
return $(el).val().replace(rCRLF, '\r\n');
};
/**
* Clears the form data. Takes the following actions on the form's input fields:
*  - input text fields will have their 'value' property set to the empty string
*  - select elements will have their 'selectedIndex' property set to -1
*  - checkbox and radio inputs will have their 'checked' property set to false
*  - inputs of type submit, button, reset, and hidden will *not* be effected
*  - button elements will *not* be effected
*/
$.fn.clearForm = function(includeHidden) {
return this.each(function() {
$('input,select,textarea', this).clearFields(includeHidden);
});
};
/**
* Clears the selected form elements.
*/
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
return this.each(function() {
var t = this.type, tag = this.tagName.toLowerCase();
if (re.test(t) || tag === 'textarea') {
this.value = '';
} else if (t === 'checkbox' || t === 'radio') {
this.checked = false;
} else if (tag === 'select') {
this.selectedIndex = -1;
} else if (t === 'file') {
if (/MSIE/.test(navigator.userAgent)) {
$(this).replaceWith($(this).clone(true));
} else {
$(this).val('');
}
} else if (includeHidden) {
// includeHidden can be the value true, or it can be a selector string
// indicating a special test; for example:
// $('#myForm').clearForm('.special:hidden')
// the above would clean hidden inputs that have the class of 'special'
if ((includeHidden === true && /hidden/.test(t)) ||
(typeof includeHidden === 'string' && $(this).is(includeHidden))) {
this.value = '';
}
}
});
};
/**
* Resets the form data or individual elements. Takes the following actions
* on the selected tags:
* - all fields within form elements will be reset to their original value
* - input / textarea / select fields will be reset to their original value
* - option / optgroup fields (for multi-selects) will defaulted individually
* - non-multiple options will find the right select to default
* - label elements will be searched against its 'for' attribute
* - all others will be searched for appropriate children to default
*/
$.fn.resetForm = function() {
return this.each(function() {
var el = $(this);
var tag = this.tagName.toLowerCase();
switch (tag) {
case 'input':
this.checked = this.defaultChecked;
// fall through
case 'textarea':
this.value = this.defaultValue;
return true;
case 'option':
case 'optgroup':
var select = el.parents('select');
if (select.length && select[0].multiple) {
if (tag === 'option') {
this.selected = this.defaultSelected;
} else {
el.find('option').resetForm();
}
} else {
select.resetForm();
}
return true;
case 'select':
el.find('option').each(function(i) {// eslint-disable-line consistent-return
this.selected = this.defaultSelected;
if (this.defaultSelected && !el[0].multiple) {
el[0].selectedIndex = i;
return false;
}
});
return true;
case 'label':
var forEl = $(el.attr('for'));
var list = el.find('input,select,textarea');
if (forEl[0]) {
list.unshift(forEl[0]);
}
list.resetForm();
return true;
case 'form':
// guard against an input with the name of 'reset'
// note that IE reports the reset function as an 'object'
if (typeof this.reset === 'function' || (typeof this.reset === 'object' && !this.reset.nodeType)) {
this.reset();
}
return true;
default:
el.find('form,input,label,select,textarea').resetForm();
return true;
}
});
};
/**
* Enables or disables any matching elements.
*/
$.fn.enable = function(b) {
if (typeof b === 'undefined') {
b = true;
}
return this.each(function() {
this.disabled = !b;
});
};
/**
* Checks/unchecks any matching checkboxes or radio buttons and
* selects/deselects and matching option elements.
*/
$.fn.selected = function(select) {
if (typeof select === 'undefined') {
select = true;
}
return this.each(function() {
var t = this.type;
if (t === 'checkbox' || t === 'radio') {
this.checked = select;
} else if (this.tagName.toLowerCase() === 'option') {
var $sel = $(this).parent('select');
if (select && $sel[0] && $sel[0].type === 'select-one') {
// deselect all other options
$sel.find('option').selected(false);
}
this.selected = select;
}
});
};
// expose debug var
$.fn.ajaxSubmit.debug = false;
// helper fn for console logging
function log() {
if (!$.fn.ajaxSubmit.debug) {
return;
}
var msg = '[jquery.form] ' + Array.prototype.join.call(arguments, '');
if (window.console && window.console.log) {
window.console.log(msg);
} else if (window.opera && window.opera.postError) {
window.opera.postError(msg);
}
}
}));
/*
* jqModal - Minimalist Modaling with jQuery
*
* Copyright (c) 2007-2015 Brice Burgess @IceburgBrice
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
* $Version: 1.4.0 (2015.08.16 +r25)
* Requires: jQuery 1.2.3+
*/
(function($) {
/**
* Initialize elements as "modals". Modals typically are popup dialogs,
* notices, modal windows, &c.
*
* @name jqm
* @param options user defined options, augments defaults.
* @type jQuery
* @cat Plugins/jqModal
*/
$.fn.jqm=function(options){
return this.each(function(){
var jqm = $(this).data('jqm') || $.extend({ID: I++}, $.jqm.params),
o = $.extend(jqm,options);
// add/extend options to modal and mark as initialized
$(this).data('jqm',o).addClass('jqm-init')[0]._jqmID = o.ID;
// ... Attach events to trigger showing of this modal
$(this).jqmAddTrigger(o.trigger);
});
};
/**
* Matching modals will have their jqmShow() method fired by attaching a
*   onClick event to elements matching `trigger`.
*
* @name jqmAddTrigger
* @param trigger a a string selector, jQuery collection, or DOM element.
*/
$.fn.jqmAddTrigger=function(trigger){
if(trigger){
return this.each(function(){
if (!addTrigger($(this), 'jqmShow', trigger))
err("jqmAddTrigger must be called on initialized modals");
});
}
};
/**
* Matching modals will have their jqmHide() method fired by attaching an
*   onClick event to elements matching `trigger`.
*
* @name jqmAddClose
* @param trigger a string selector, jQuery collection, or DOM element.
*/
$.fn.jqmAddClose=function(trigger){
if(trigger){
return this.each(function(){
if(!addTrigger($(this), 'jqmHide', trigger))
err ("jqmAddClose must be called on initialized modals");
});
}
};
/**
* Open matching modals (if not shown)
*/
$.fn.jqmShow=function(trigger){
return this.each(function(){ if(!this._jqmShown) show($(this), trigger); });
};
/**
* Close matching modals
*/
$.fn.jqmHide=function(trigger){
return this.each(function(){ if(this._jqmShown) hide($(this), trigger); });
};
// utility functions
var
err = function(msg){
if(window.console && window.console.error) window.console.error(msg);
}, show = function(m, t){
/**
* m = modal element (as jQuery object)
* t = triggering element
*
* o = options
* z = z-index of modal
* v = overlay element (as jQuery object)
* h = hash (for jqModal <= r15 compatibility)
*/
t = t || window.event;
var o = m.data('jqm'),
z = (parseInt(m.css('z-index'))) || 3000,
v = $('<div></div>').addClass(o.overlayClass).css({
height:'100%',
width:'100%',
position:'fixed',
left:0,
top:0,
'z-index':z-1,
opacity:o.overlay/100
}),
// maintain legacy "hash" construct
h = {w: m, c: o, o: v, t: t};
m.css('z-index',z);
if(o.ajax){
var target = o.target || m,
url = o.ajax;
target = (typeof target === 'string') ? $(target,m) : $(target);
if(url.substr(0,1) === '@') url = $(t).attr(url.substring(1));
// load remote contents
target.load(url,function(){
if(o.onLoad) o.onLoad.call(this,h);
});
// show modal
if(o.ajaxText) target.html(o.ajaxText);
open(h);
}
else { open(h); }
}, hide = function(m, t){
/**
* m = modal element (as jQuery object)
* t = triggering element
*
* o = options
* h = hash (for jqModal <= r15 compatibility)
*/
t = t || window.event;
var o = m.data('jqm'),
// maintain legacy "hash" construct
h = {w: m, c: o, o: m.data('jqmv'), t: t};
close(h);
}, onShow = function(hash){
// onShow callback. Responsible for showing a modal and overlay.
//  return false to stop opening modal.
// hash object;
//  w: (jQuery object) The modal element
//  c: (object) The modal's options object
//  o: (jQuery object) The overlay element
//  t: (DOM object) The triggering element
// if overlay not disabled, prepend to body
if(hash.c.overlay > 0) hash.o.prependTo('body');
// make modal visible
hash.w.show();
// call focusFunc (attempts to focus on first input in modal)
$.jqm.focusFunc(hash.w,true);
return true;
}, onHide = function(hash){
// onHide callback. Responsible for hiding a modal and overlay.
//  return false to stop closing modal.
// hash object;
//  w: (jQuery object) The modal element
//  c: (object) The modal's options object
//  o: (jQuery object) The overlay element
//  t: (DOM object) The triggering element
// hide modal and if overlay, remove overlay.
if(hash.w.hide() && hash.o) hash.o.remove();
return true;
},  addTrigger = function(m, key, trigger){
// addTrigger: Adds a jqmShow/jqmHide (key) event click on modal (m)
//  to all elements that match trigger string (trigger)
var jqm = m.data('jqm');
if(jqm) return $(trigger).each(function(){
this[key] = this[key] || [];
// register this modal with this trigger only once
if($.inArray(jqm.ID,this[key]) < 0) {
this[key].push(jqm.ID);
// register trigger click event for this modal
//  allows cancellation of show/hide event from
$(this).on('click',function(e){
if(!e.isDefaultPrevented()) m[key](this);
return false;
});
}
});
}, open = function(h){
// open: executes the onOpen callback + performs common tasks if successful
// transform legacy hash into new var shortcuts
var m = h.w,
v = h.o,
o = h.c;
// execute onShow callback
if(o.onShow(h) !== false){
// mark modal as shown
m[0]._jqmShown = true;
// if modal:true  dialog
//   Bind the Keep Focus Function [F] if no other Modals are active
// else,
//   trigger closing of dialog when overlay is clicked
if(o.modal){
if(!ActiveModals[0]){ F('bind'); }
ActiveModals.push(m[0]);
}
else m.jqmAddClose(v);
//  Attach events to elements inside the modal matching closingClass
if(o.closeClass) m.jqmAddClose($('.' + o.closeClass,m));
// if toTop is true and overlay exists;
//  remember modal DOM position with <span> placeholder element, and move
//  the modal to a direct child of the body tag (after overlyay)
if(o.toTop && v)
m.before('<span id="jqmP'+o.ID+'"></span>').insertAfter(v);
// remember overlay (for closing function)
m.data('jqmv',v);
// close modal if the esc key is pressed and closeOnEsc is set to true
m.off("keydown",$.jqm.closeOnEscFunc);
if(o.closeOnEsc) {
m.attr("tabindex", 0).on("keydown",$.jqm.closeOnEscFunc).trigger('focus');
}
}
}, close = function(h){
// close: executes the onHide callback + performs common tasks if successful
// transform legacy hash into new var shortcuts
var m = h.w,
v = h.o,
o = h.c;
// execute onHide callback
if(o.onHide(h) !== false){
// mark modal as !shown
m[0]._jqmShown = false;
// If modal, remove from modal stack.
// If no modals in modal stack, unbind the Keep Focus Function
if(o.modal){
ActiveModals.pop();
if(!ActiveModals[0]) F('unbind');
}
// IF toTop was passed and an overlay exists;
//  Move modal back to its "remembered" position.
if(o.toTop && v) $('#jqmP'+o.ID).after(m).remove();
}
},  F = function(t){
// F: The Keep Focus Function (for modal: true dialos)
// Binds or Unbinds (t) the Focus Examination Function (X)
$(document)[t]("keypress keydown mousedown",X);
}, X = function(e){
// X: The Focus Examination Function (for modal: true dialogs)
var targetModal = $(e.target).data('jqm') ||
$(e.target).parents('.jqm-init:first').data('jqm');
var activeModal = ActiveModals[ActiveModals.length-1];
// allow bubbling if event target is within active modal dialog
return (targetModal && targetModal.ID === activeModal._jqmID) ?
true : $.jqm.focusFunc(activeModal,e);
},
I = 0,   // modal ID increment (for nested modals)
ActiveModals = [];  // array of active modals
// $.jqm, overridable defaults
$.jqm = {
/**
*  default options
*
* (Integer)   overlay      - [0-100] Translucency percentage (opacity) of the body covering overlay. Set to 0 for NO overlay, and up to 100 for a 100% opaque overlay.
* (String)    overlayClass - Applied to the body covering overlay. Useful for controlling overlay look (tint, background-image, &c) with CSS.
* (String)    closeClass   - Children of the modal element matching `closeClass` will fire the onHide event (to close the modal).
* (Mixed)     trigger      - Matching elements will fire the onShow event (to display the modal). Trigger can be a selector String, a jQuery collection of elements, a DOM element, or a False boolean.
* (String)    ajax         - URL to load content from via an AJAX request. False to disable ajax. If ajax begins with a "@", the URL is extracted from the attribute of the triggering element (e.g. use '@data-url' for; <a href="#" class="jqModal" data-url="modal.html">...)
* (Mixed)     target       - Children of the modal element to load the ajax response into. If false, modal content will be overwritten by ajax response. Useful for retaining modal design.
*                            Target may be a selector string, jQuery collection of elements, or a DOM element -- and MUST exist as a child of the modal element.
* (String)    ajaxText     - Text shown while waiting for ajax return. Replaces HTML content of `target` element.
* (Boolean)   modal        - If true, user interactivity will be locked to the modal window until closed.
* (Boolean)   toTop        - If true, modal will be posistioned as a first child of the BODY element when opened, and its DOM posistion restored when closed. Useful for overcoming z-Index container issues.
* (Function)  onShow       - User defined callback function fired when modal opened.
* (Function)  onHide       - User defined callback function fired when modal closed.
* (Function)  onLoad       - User defined callback function fired when ajax content loads.
*/
params: {
overlay: 50,
overlayClass: 'jqmOverlay',
closeClass: 'jqmClose',
closeOnEsc: false,
trigger: '.jqModal',
ajax: false,
target: false,
ajaxText: '',
modal: false,
toTop: false,
onShow: onShow,
onHide: onHide,
onLoad: false
},
// focusFunc is fired:
//   a) when a modal:true dialog is shown,
//   b) when an event occurs outside an active modal:true dialog
// It is passed the active modal:true dialog as well as event
focusFunc: function(activeModal, e) {
// if the event occurs outside the activeModal, focus on first element
if(e) $(':input:visible:first',activeModal).trigger('focus');
// lock interactions to the activeModal
return false;
},
// closeOnEscFunc is attached to modals where closeOnEsc param true.
closeOnEscFunc: function(e){
if (e.keyCode === 27) {
$(this).jqmHide();
return false;
}
}
};
})( jQuery );
// CREDIT GOES TO: http://blog.stchur.com/2007/04/06/serializing-objects-in-javascript/
jQuery.serialize = function(_obj)
{
// Let Gecko browsers do this the easy way
if (typeof _obj.toSource !== 'undefined' && typeof _obj.callee === 'undefined')
{
return _obj.toSource();
}
// Other browsers must do it the hard way
switch (typeof _obj)
{
// numbers, booleans, and functions are trivial:
// just return the object itself since its default .toString()
// gives us exactly what we want
case 'number':
case 'boolean':
case 'function':
return _obj;
break;
// for JSON format, strings need to be wrapped in quotes
case 'string':
return '"' + _obj + '"';
break;
case 'object':
var str;
if (_obj.constructor === Array || typeof _obj.callee !== 'undefined')
{
str = '[';
var i, len = _obj.length;
for (i = 0; i < len-1; i++) { str += jQuery.serialize(_obj[i]) + ','; }
str += serialize(_obj[i]) + ']';
}
else
{
str = '{';
var key;
for (key in _obj) { str += '"' + key + '":' + jQuery.serialize(_obj[key]) + ','; }
str = str.replace(/\,$/, '') + '}';
}
return str;
break;
default:
return 'UNKNOWN';
break;
}
}
/*!
* jQuery Cookie Plugin v1.4.1.1
* FoM: Replaced depricated isFunction()
* https://github.com/carhartl/jquery-cookie
*
* Copyright 2006, 2014 Klaus Hartl
* Released under the MIT license
*/
(function (factory) {
if (typeof define === 'function' && define.amd) {
// AMD (Register as an anonymous module)
define(['jquery'], factory);
} else if (typeof exports === 'object') {
// Node/CommonJS
module.exports = factory(require('jquery'));
} else {
// Browser globals
factory(jQuery);
}
}(function ($) {
var pluses = /\+/g;
function encode(s) {
return config.raw ? s : encodeURIComponent(s);
}
function decode(s) {
return config.raw ? s : decodeURIComponent(s);
}
function stringifyCookieValue(value) {
return encode(config.json ? JSON.stringify(value) : String(value));
}
function parseCookieValue(s) {
if (s.indexOf('"') === 0) {
// This is a quoted cookie as according to RFC2068, unescape...
s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
}
try {
// Replace server-side written pluses with spaces.
// If we can't decode the cookie, ignore it, it's unusable.
// If we can't parse the cookie, ignore it, it's unusable.
s = decodeURIComponent(s.replace(pluses, ' '));
return config.json ? JSON.parse(s) : s;
} catch(e) {}
}
function read(s, converter) {
var value = config.raw ? s : parseCookieValue(s);
//return $.isFunction(converter) ? converter(value) : value;
return (typeof converter === "function") ? converter(value) : value;
}
var config = $.cookie = function (key, value, options) { // Write
//if (arguments.length > 1 && !$.isFunction(value)) {
if (arguments.length > 1 && !(typeof value === "function")) {
options = $.extend({}, config.defaults, options);
if (typeof options.expires === 'number') {
var days = options.expires, t = options.expires = new Date();
t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
}
return (document.cookie = [
encode(key), '=', stringifyCookieValue(value),
options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
options.path    ? '; path=' + options.path : '',
options.domain  ? '; domain=' + options.domain : '',
options.secure  ? '; secure' : ''
].join(''));
}
// Read
var result = key ? undefined : {},
// To prevent the for loop in the first place assign an empty array
// in case there are no cookies at all. Also prevents odd result when
// calling $.cookie().
cookies = document.cookie ? document.cookie.split('; ') : [],
i = 0,
l = cookies.length;
for (; i < l; i++) {
var parts = cookies[i].split('='),
name = decode(parts.shift()),
cookie = parts.join('=');
if (key === name) {
// If second argument (value) is a function it's a converter...
result = read(cookie, value);
break;
}
// Prevent storing a cookie that we couldn't decode.
if (!key && (cookie = read(cookie)) !== undefined) {
result[name] = cookie;
}
}
return result;
};
config.defaults = {};
$.removeCookie = function (key, options) {  // Must not alter options, thus extending a fresh object...
$.cookie(key, '', $.extend({}, options, { expires: -1 }));
return !$.cookie(key);
};
}));
// requires the jquery.cookie.js, and the jquery.serialize.js
jQuery.supercookie = function(name, key, value, options) {
if (typeof value != 'undefined') { // name and value given, set cookie
var cookieObj = jQuery.supercookie(name);
cookieObj[key] = value;
var cookieVal = escape(jQuery.serialize(cookieObj));
jQuery.cookie(name, cookieVal, options);
} else { // only name given, get cookie
var cookie = jQuery.cookie(name);
var cookieObj = null;
if (cookie) {
eval('cookieObj = ' + unescape(cookie));
}
if (!cookieObj) cookieObj = {};
if (key){
if (cookieObj[key]){
return cookieObj[key];
} else {
return null;
}
} else {
return cookieObj;
}
}
};
/*!
* FoM: Github fixes and isFunction() deprication fix, hidden resize() comments
* jQuery resize event - v1.1 - 3/14/2010
* http://benalman.com/projects/jquery-resize-plugin/
*
* Copyright (c) 2010 "Cowboy" Ben Alman
* Dual licensed under the MIT and GPL licenses.
* http://benalman.com/about/license/
*/
// Script: jQuery resize event
//
// *Version: 1.1, Last updated: 3/14/2010*
//
// Project Home - http://benalman.com/projects/jquery-resize-plugin/
// GitHub       - http://github.com/cowboy/jquery-resize/
// Source       - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.js
// (Minified)   - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.min.js (1.0kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// This working example, complete with fully commented code, illustrates a few
// ways in which this plugin can be used.
//
// resize event - http://benalman.com/code/projects/jquery-resize/examples/resize/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-resize/unit/
//
// About: Release History
//
// 1.1 - (3/14/2010) Fixed a minor bug that was causing the event to trigger
//       immediately after bind in some circumstances. Also changed $.fn.data
//       to $.data to improve performance.
// 1.0 - (2/10/2010) Initial release
(function($,window,undefined){
'$:nomunge'; // Used by YUI compressor.
// A jQuery object containing all non-window elements to which the resize
// event is bound.
var elems = $([]),
// Extend $.resize if it already exists, otherwise create it.
jq_resize = $.resize = $.extend( $.resize, {} ),
timeout_id,
// Reused strings.
str_setTimeout = 'setTimeout',
str_resize = 'resize',
str_data = str_resize + '-special-event',
str_delay = 'delay',
str_throttle = 'throttleWindow';
// Property: jQuery.resize.delay
//
// The numeric interval (in milliseconds) at which the resize event polling
// loop executes. Defaults to 250.
jq_resize[ str_delay ] = 250;
jq_resize[ str_throttle ] = true;
$.event.special[ str_resize ] = {
// Called only when the first 'resize' event callback is bound per element.
setup: function() {
// Since window has its own native 'resize' event, return false so that
// jQuery will bind the event using DOM methods. Since only 'window'
// objects have a .setTimeout method, this should be a sufficient test.
// Unless, of course, we're throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var elem = $(this);
// Add this element to the list of internal elements to monitor.
elems = elems.add( elem );
// Initialize data store on the element.
$.data( this, str_data, { w: elem.width(), h: elem.height() } );
// If this is the first element added, start the polling loop.
if ( elems.length === 1 ) {
loopy();
}
},
// Called only when the last 'resize' event callback is unbound per element.
teardown: function() {
// Since window has its own native 'resize' event, return false so that
// jQuery will unbind the event using DOM methods. Since only 'window'
// objects have a .setTimeout method, this should be a sufficient test.
// Unless, of course, we're throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var elem = $(this);
// Remove this element from the list of internal elements to monitor.
elems = elems.not( elem );
// Remove any data stored on the element.
elem.removeData( str_data );
// If this is the last element removed, stop the polling loop.
if ( !elems.length ) {
clearTimeout( timeout_id );
}
},
// Called every time a 'resize' event callback is bound per element (new in
// jQuery 1.4).
add: function( handleObj ) {
// Since window has its own native 'resize' event, return false so that
// jQuery doesn't modify the event object. Unless, of course, we're
// throttling the 'resize' event for window.
if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
var old_handler;
// The new_handler function is executed every time the event is triggered.
// This is used to update the internal element data store with the width
// and height when the event is triggered manually, to avoid double-firing
// of the event callback. See the "Double firing issue in jQuery 1.3.2"
// comments above for more information.
function new_handler( e, w, h ) {
var elem = $(this),
data = $.data( this, str_data );
// MODIFIED BY David McReynolds Daylight Studio 2013-09-04 - added check that data exists so it won't throw an error
if (data){
data.w = w !== undefined ? w : elem.width();
data.h = h !== undefined ? h : elem.height();
old_handler.apply( this, arguments );
}
};
// This may seem a little complicated, but it normalizes the special event
// .add method between jQuery 1.4/1.4.1 and 1.4.2+
//if ( $.isFunction( handleObj ) ) {
if ( (typeof handleObj === "function") ) {    // 1.4, 1.4.1
old_handler = handleObj;
return new_handler;
} else {
// 1.4.2+
old_handler = handleObj.handler;
handleObj.handler = new_handler;
}
}
};
function loopy() {
// Start the polling loop, asynchronously.
timeout_id = window[ str_setTimeout ](function(){
// Iterate over all elements to which the 'resize' event is bound.
elems.each(function(){
var elem = $(this),
width = elem.width(),
height = elem.height(),
data = $.data( this, str_data );
// If element size has changed since the last time, update the element
// data store and trigger the 'resize' event.
// MODIFIED BY David McReynolds Daylight Studio 2014-05-22 - added check that data exists so it won't throw an error
if (data && (width !== data.w || height !== data.h )) {
elem.trigger( str_resize, [ data.w = width, data.h = height ] );
}
});
// Loop.
loopy();
}, jq_resize[ str_delay ] );
};
//})(jQuery,this);
})(jQuery,window);
function initFuelNamespace(){
var f;
if (window.fuel == undefined){
if (top.window.fuel != undefined){
f = top.window.fuel;
} else {
f = {};
}
} else {
f = window.fuel;
}
return f;
}
//fuel = initFuelNamespace();
//console.log(fuel)
if (typeof(window.fuel) == 'undefined'){
window.fuel = {};
}
fuel.lang = function(key){
return __FUEL_LOCALIZED__[key];
}
// used to get id values in case the form fields are namespaced
fuel.getFieldId = function(field, context){
if (window.__FUEL_INLINE_EDITING != undefined){
var val = $('.__fuel_module__', context).attr('id');
var prefix = val.split('--')[0];
return prefix + '--' + field;
} else {
return field;
}
}
fuel.getModule = function(context){
// inline editing
if (window.__FUEL_INLINE_EDITING != undefined){
return $('.__fuel_module__', context).val();
} else {
// jqx controller instance name is "page"
return page.module;
}
}
fuel.modalWindow = function(html, cssClass, autoResize, onLoadCallback, onCloseCallback){
var modalId = '__FUEL_modal__';
if (!cssClass) cssClass = '';
var $context = $('body', window.document);
if (!$('#' + modalId, $context).length){
var modalHTML = '<div id="' + modalId + '"><div class="loader"></div><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div></div>';
} else {
$('#' + modalId, $context).html('<div class="loader"></div><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div>');
}
$context.append(modalHTML);
$modal = $('#' + modalId, $context);
$modal.attr('class', '__fuel__ __fuel_modal__ jqmWindow ' + cssClass)
// Hack to prevent the iframe from refreshing on close
$(document).off('mousedown', '.modal_close');
$(document).on('mousedown', '.modal_close', function(e){
e.preventDefault();
$('.modal_content').empty();
$modal.jqmHide();
})
var modalOnHide = function(){
$('#' + modalId, $context).hide();
$('.jqmOverlay', $context).remove();
if (onCloseCallback) onCloseCallback();
}
var modalWidth = $modal.outerWidth();
var centerWidth = -((modalWidth/2));
$modal.css('marginLeft', centerWidth + 'px');
// show it first so we don't get the cancellation error in the console
// set jqm window options
var jqmOpts = { onHide: modalOnHide, toTop:true };
if (onLoadCallback){
jqmOpts.onLoad = onLoadCallback;
}
$modal.jqm(jqmOpts).jqmShow();
$modal.find('.modal_content').empty().append(html);
$modal.find('iframe').on('load', function(){
$('.jqmWindow .loader', $context).hide();
var iframe = this;
var contentDoc = iframe.contentDocument;
$('.cancel', contentDoc).add('.modal_close').on('click',function(e){
e.preventDefault();
$modal.jqmHide();
})
if (autoResize){
setTimeout(function(){
docHeight = fuel.calcHeight(contentDoc);
if (iframe.contentWindow){
$(iframe.contentWindow.parent.document).find('#' + modalId + 'iframe').height(docHeight);
fuel.cascadeIframeWindowSize(docHeight);
$(iframe).height(docHeight);
}
}, 250);
}
})
return $modal;
}
fuel.closeModal = function(){
var modalId = '__FUEL_modal__';
$modal = $('#' + modalId, document.top);
if ($modal.find('.modal_close').length){
$modal.find('.modal_close').trigger('mousedown');
} else {
$('#' + modalId).jqmHide();
}
}
fuel.getModule = function(context){
if (window.fuel && window.fuel.module){
return window.fuel.module;
}
if (context == undefined) context = null;
var module = ($('.__fuel_module__', context).length) ? $('.__fuel_module__', context).val() : null;
return module;
}
fuel.getModuleURI = function(context){
if (context == undefined) context = null;
var module = ($('.__fuel_module_uri__').length) ? $('.__fuel_module_uri__').val() : null;
return module;
}
fuel.isTop = function(){
return self == top;
}
fuel.windowLevel = function(){
var level = 0;
var win = window;
while (win != top && win.parent != null){
level++;
win = win.parent;
}
return level;
}
fuel.calcHeight = function(context){
var height = 0;
if ($('#login', context).length){
var elems = '#login';
} else {
var elems = '#fuel_main_top_panel, #fuel_actions, #fuel_notification, #fuel_main_content_inner, #list_container, .instructions, .modal_height';
}
$(elems, context).each(function(i){
// must use false to get around bug with jQuery 1.8
var outerHeight = parseInt($(this).outerHeight(false));
if (outerHeight) height += outerHeight;
})
if (height > 600) {
height = 600;
} else {
height += 30;
}
return height;
}
fuel.adjustIframeWindowSize = function(){
var iframe = $('.inline_iframe', top.window.document);
if (iframe.length){
iframe = iframe[0];
var contentDoc = iframe.contentDocument;
var height = parseInt(fuel.calcHeight(contentDoc));
var width = parseInt($('#fuel_main_content_inner .form', contentDoc).width()) + 50;
$(iframe).height(height);
$(iframe).width(width);
}
}
fuel.cascadeIframeWindowSize = function(height){
var level = 0;
if (height) height = height + 100;
//var win = window;
// console.log(win.document.title)
$('.inline_iframe', top.window.document).height(height);
// do
// {
// level++;
// //height = fuel.calcHeight(win.document);
// console.log($('.inline_iframe', win.document))
// $('.inline_iframe', win.document).height(height);
// win = win.parent;
// console.log(win.document.title)
//
// } while (win != top && win.parent != null)
//return level;
}
// exposed fuel methods
if (fuel == undefined) var fuel = {};
(function($) {
var initObj = __FUEL_INIT_PARAMS__;
var pageId = initObj.pageId;
var pageLocation = initObj.pageLocation;
var basePath = initObj.basePath;
var cookiePath = initObj.cookiePath;
var imgPath = initObj.imgPath;
var cssPath = initObj.cssPath;
var jsPath = initObj.jsPath;
var assetsImgPath = initObj.assetsImgPath;
var assetsPath = initObj.assetsPath;
var assetsAccept = initObj.assetsAccept;
var editor = initObj.editor;
var editorConfig = initObj.editorConfig;
var markers = null;
var X_OFFSET = 16;
var Y_OFFSET = 16;
var editorsOn = (parseInt($.supercookie('fuel_bar', 'show_editable_areas')) == 1);
var fuelBarOn = (parseInt($.supercookie('fuel_bar', 'show_fuel_bar')) == 1);
var activeEditor;
var activeField;
var assetFolder;
var iconHeight = 16;
var maxAdjustLoops = (fuel.maxAdjustLoops) ? fuel.maxAdjustLoops : 10;
// limit it to the most common for performance
var useAutoAdjust = (fuel.useAutoAdjust === false) ? false : true;
var resizeTags = (fuel.resizeTags) ? fuel.resizeTags : 'section,div,p,li';
jQuery.resize.delay = (fuel.resizeDelay) ? fuel.resizeDelay : 1000;
function lang(key){
return __FUEL_LOCALIZED__[key];
}
$(document).ready(function(){
$('body').addClass('__fuel_inline__');
function init(){
// disable the toolbar if it is being view from within the admin
if (window.top != window){
$('#__fuel_edit_bar__').hide();
return;
}
initMarkers();
initFUELBar();
// bind exposed global methods
fuel.refresh = function(){
refresh();
}
fuel.modalWindow = function (html, cssClass, callback){
var modalId = '__FUEL_modal__';
if (!cssClass) cssClass = '';
var $context = $('body', top.window.document);
var modalHtml = '<a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div>';
if (!$('#' + modalId).length){
var modalHTML = '<div id="' + modalId + '" class="__fuel__ __fuel_modal__ jqmWindow ' + cssClass + '"><a href="#" class="modal_close jqmClose"></a><div class="modal_content"></div></div>';
$context.append(modalHTML);
}
// add loading graphic
$('#' + modalId, $context).append('<div class="loader"></div>');
// add overlay and hide iframe overlay
//$('.jqmOverlay', $context).hide();
$modal = $('#' + modalId, $context);
$modal.find('.modal_content').empty().append(html);
$modal.find('iframe').on('load', function(e){
$('.jqmWindow .loader', $context).remove();
var iframe = this;
var contentDoc = iframe.contentDocument;
var actionsHeight = $('#fuel_actions', contentDoc).length ? $('#fuel_actions', contentDoc).outerHeight(false) : 0;
var notificationsHeight = $('#fuel_notification', contentDoc).length ? $('#fuel_notification', contentDoc).outerHeight(false) : 0;
var mainContentHeight =  $('#fuel_main_content_inner', contentDoc).length ? $('#fuel_main_content_inner', contentDoc).outerHeight(false) : 0;
var listTableHeight = $('#data_table_container', contentDoc).length ? $('#data_table_container', contentDoc).outerHeight(false) : 0;
docHeight = actionsHeight + notificationsHeight + mainContentHeight + listTableHeight + 30; // 30 is a fudge factor
//docHeight = 100
// var heightFudge = $('#fuel_notification', contentDoc).outerHeight() + 30; // padding for #fuel_main_content_inner is 15 top and 15 bottom
// heightFudge += $('#fuel_actions', contentDoc).outerHeight();
// var docHeight = $('#fuel_main_content_inner', contentDoc).outerHeight() + heightFudge; // bottom margin is added... not sure from what though
//console.log(docHeight)
if (docHeight > 450) docHeight = 450;
var docWidth = 850; // 74 includes the 37 in padding on each side
$(iframe).height(docHeight);
$(iframe).width(docWidth);
})
$modal.jqm({}).jqmShow();
}
fuel.refreshIframeSize = function(iframe){
var i = 0;
// polling
var interval = setInterval(function(){
fuel.setIframeSize(iframe);
if (i > 20) clearInterval(interval);
i++;
}, 100);
}
fuel.setIframeSize = function(iframe){
var MIN_WIDTH = 850;
var contentDoc = iframe.contentDocument;
var docHeight = fuel.calcHeight(contentDoc);
if ($('#fuel_main_content_inner .form, #fuel_actions', contentDoc).length){
var width1 = $('#fuel_main_content_inner .form', contentDoc).outerWidth(false) + 74; // 74 includes the 37 in padding on each side
var width2 = $('#fuel_actions', contentDoc).outerWidth(false);
var docWidth = (width1 > width2) ? width1 : width2;
// check if fuel_actions is there so that we don't make it too wide for single variables being edited
if (docWidth < MIN_WIDTH && $('#fuel_actions', contentDoc).length) docWidth = MIN_WIDTH;
} else if ($('#login', contentDoc).length){
docWidth = $('#login', contentDoc).width();
} else {
docWidth = $(contentDoc).width();
}
if (docHeight == 0){
docHeight = $(contentDoc).height();
}
$(iframe).height(docHeight);
$(iframe).width(docWidth);
}
}
function initMarkers(){
$('.__fuel_edit__').remove();
var markers = $(".__fuel_marker__");
var toggleEditOff = true;
if (markers.length > 0){
$body = $('body');
markers.each(function(i){
var $this = $(this);
var module = $this.attr('data-module');
if ((module == 'pagevariables' && pageId != 0) || module != 'pagevariables'){
$this.attr('id', '__fuel_marker__' + i);
var coords = getMarkerPosition($this);
var varName = $this.attr('title');
var newClass = ($this.attr('data-rel').substr(0, 6) == 'create') ? ' __fuel_edit_marker_new__' : '';
var publishedClass = ($this.attr('data-published') == '0') ? ' __fuel_edit_marker_unpublished__' : '';
var html = '<div id="__fuel_edit__' + i + '" style="left:' + coords.x + 'px; top:' + coords.y + 'px;" class="__fuel__ __fuel_edit__" title="' + varName + '" data-module="' + module + '">';
var dataHref = $this.attr('data-href').replace(/\|/, '/');
html += '<a href="' + dataHref + '" rel="' + $this.attr('data-rel') + '" class="__fuel_edit_marker__'+ newClass + publishedClass + '">';
html += '<span class="__fuel_edit_marker_inner__">' + varName + '</span>';
html += '</a>';
html += '<div class="__fuel_edit_form__" style="display: none;"><img src="' + imgPath + 'spinner_sm.gif" width="16" height="16" alt="loading"></div>';
html += '</div>';
$body.append(html);
toggleEditOff = false;
}
});
$('.__fuel_edit_marker_inner__').hide();
initEditors();
}
if (toggleEditOff) $('#__fuel_page_edit_toggle__').parent().hide();
}
function refresh(){
if (editorsOn){
moveMarkers();
if (activeEditor){
var iframe = activeEditor.find('iframe')[0];
//fuel.setIframeSize(iframe);
}
}
}
function moveMarkers(){
var markers = $(".__fuel_marker__");
markers.each(function(i){
var $this = $(this);
var coords = getMarkerPosition($this);
$('#__fuel_edit__' + i).css({left: coords.x, top: coords.y});
// determine if it is visible so that we can filter out the hidden to speed things up
if ($this.filter(':hidden').length != 0) {
$('#__fuel_edit__' + i).hide();
} else {
$('#__fuel_edit__' + i).show();
}
});
// re-adjust markers so they don't overlap
var editors = $(".__fuel_edit__:visible");
editors.each(function(i){
adjustPosition(editors, $(this), 0);
});
}
function getMarkerPosition(marker){
var offset = marker.offset();
var xCoord = offset.left;
var yCoord = offset.top + iconHeight; // 16 is the icon height
var x = (xCoord <= X_OFFSET) ? 0 : xCoord - X_OFFSET;
var y = (yCoord <= Y_OFFSET) ? 0 : yCoord - Y_OFFSET;
return {x:x, y:y};
}
// used to prevent overlaps of editors
function adjustPosition(editors, $obj, counter){
editors.each(function(i){
var $compareObj = $(this);
var topPos = parseInt($obj.css('top'));
var leftPos = parseInt($obj.css('left'));
var objAttrsId = $obj.attr('id');
var objCompareAttrsId = $compareObj.attr('id');
if (counter <= maxAdjustLoops && $obj.attr('id') != $compareObj.attr('id') &&
Math.abs(topPos - parseInt($compareObj.css('top'))) < Y_OFFSET &&
Math.abs(leftPos - parseInt($compareObj.css('left'))) < X_OFFSET){
$compareObj.css('top', (topPos + Y_OFFSET) + 'px');
counter++;
adjustPosition(editors, $obj, counter);
return false;
}
});
}
function initEditors(){
var formAction = '';
var editors = $('.__fuel_edit__');
var resetCss = {height: 'auto', width: 'auto', opacity: 1, display: 'block'};
var closeEditor = function(){
// turn off inline editing mode
if (activeEditor){
var iframe = activeEditor.find('iframe')[0];
var contentDoc = iframe.contentDocument;
// if there was a successful save, then we need to refresh the page
if ($('.success', contentDoc).length){
top.window.location.reload();
} else {
activeEditor.removeClass('__fuel_edit_active__');
activeEditor.find('.__fuel_edit_marker_inner__, .__fuel_edit_form__').stop().css(resetCss).hide();
activeEditor = null;
}
}
}
var ajaxSubmit = function($form){
$form.attr('action', formAction).ajaxSubmit(function(html){
if ($(html).is('error')){
var msg = $(html).html();
if (msg != '' || msg != '1'){
$form.find('.inline_errors').html(msg).animate( { backgroundColor: '#ee6060'}, 1500);
$.scrollTo($form);
}
} else {
closeEditor();
window.location.reload(true);
}
return false;
});
}
// set up cancel button
$('.__fuel_edit__ .ico_cancel').on('click', function(){
closeEditor();
return false;
});
// set up save
$('.__fuel_edit__ .ico_save').on('click', function(){
$form = $(this).parents('.__fuel_edit_form__').find('form');
ajaxSubmit($form);
return false;
});
$('.__fuel_edit__ .delete').on('click', function(){
if (confirm(lang('confirm_delete'))){
$form = $(this).parents('.__fuel_edit_form__').find('form');
$form.find('.__fuel_inline_action__').val('delete');
ajaxSubmit($form);
}
return false;
});
editors.each(function(i){
var $this = $(this);
var module = $this.attr('data-module');
var _anchor = $('.__fuel_edit_marker__', this);
_anchor.mouseover(function(){
$('.__fuel_edit_marker_inner__', this).stop().css(resetCss).show();
});
_anchor.mouseout(function(){
if ((activeEditor && activeEditor.attr('title') == $this.attr('title'))){
return;
} else {
$('.__fuel_edit_marker_inner__', this).stop().css(resetCss).hide();
}
});
_anchor.on('click',function(e){
if (!activeEditor || activeEditor != $this){
if ($('.__fuel_edit_form__', $this).children().not('img').length == 0){
var relArr = $(this).attr('rel').split('|');
var param1 = relArr[0];
if (module == 'pagevariables'){
var param2 = pageId;
} else {
var param2 = (relArr.length >= 2) ? relArr[1] : '';
}
if (param1.substr(0, 6) == 'create'){
var qString = (param2.length) ? '?' + param2 : '';
var url = $(this).attr('href') + qString;
} else {
var url = $(this).attr('href') + param1 + '/' + param2;
}
var lang = $('#__fuel_language__').val();
if (lang && lang.length){
url = url + '?lang=' + $('#__fuel_language__').val();
}
if (_anchor.next('.__fuel_edit_form__').find('iframe').length == 0){
var iframeId = '__fuel_iframe__' + $this.attr('id');
_anchor.next('.__fuel_edit_form__').html('<div class="loader"></div><iframe src="' + url +'" id="' + iframeId +'" frameborder="0" scrolling="no" class="inline_iframe"></iframe>');
$('#' + iframeId).on('load', function(){
var iframe = this;
var contentDoc = iframe.contentDocument;
// we check for the variable "saved" on the child windo
// if set to true, then we refresh the entire window so the changes can be seen
if (iframe.contentWindow.saved){
closeEditor();
window.location.reload();
} else {
$('.cancel', contentDoc).on('click',function(e){
closeEditor();
return false;
});
$('#' + iframeId).prev().hide();
fuel.refreshIframeSize(iframe);
}
})
} else {
// set the frame size just in case it wasn't set
var iframe = _anchor.next('.__fuel_edit_form__').find('iframe');
fuel.setIframeSize(iframe);
}
_anchor.next('.__fuel_edit_form__').show();
} else {
_anchor.next('.__fuel_edit_form__').show();
}
$('.__fuel_edit_marker_inner__', this).css(resetCss);
$(this).find('.__fuel_edit_marker_inner__, .__fuel_edit_form__').show();
$this.addClass('__fuel_edit_active__');
if (activeEditor && (activeEditor.attr('title') != $this.attr('title'))) {
closeEditor();
}
activeEditor = $this;
} else {
closeEditor();
}
return false;
});
});
}
function initFUELBar(){
var hideEditors = function(){
if (useAutoAdjust) $(resizeTags).off('resize', refresh);
var elem = $('#__fuel_page_edit_toggle__');
$('.__fuel_edit__').hide();
editorsOn = false;
//elem.text('Show Editable Areas');
elem.parent('li').removeClass('active');
$.supercookie('fuel_bar', 'show_editable_areas', '0', {path: cookiePath});
}
var showEditors = function(){
// use the great resize plugin to accomplish this...
if (useAutoAdjust) $(resizeTags).on('resize', refresh);
refresh(); // just in case things have moved since they were last turned off
var elem = $('#__fuel_page_edit_toggle__');
$('.__fuel_edit__').show();
editorsOn = true;
//elem.text('Hide Editable Areas');
elem.parent('li').addClass('active');
$.supercookie('fuel_bar', 'show_editable_areas', '1', {path: cookiePath});
}
var toggleEditors = function(shown){
if (shown){
hideEditors();
} else {
showEditors();
}
}
$('#__fuel_page_edit_toggle__').on('click',function(){
toggleEditors(editorsOn);
return false;
});
$('#__fuel_page_tools__').on('change',function(){
var url = $(this).val();
if (url == '') return;
var html = '<iframe src="' + url +'?id=' + pageId + '&amp;location=' + pageLocation + '" id="tool_output_iframe" frameborder="0" scrolling="no" style="border: none; height: 0px; width: 0px;"></iframe>';
fuel.modalWindow(html);
$(this).val(''); // reset it back to top
return false;
});
$('#__fuel_page_layout__').on('change',function(){
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_language__').on('change',function(){
var param = $(this).attr('name');
var lang = $(this).val();
if ($('#__fuel_language_mode__').val() == 'segment'){
if ($('#__fuel_language_default__').val() != lang){
var url = basePath + lang + '/' + pageLocation;
} else {
var url = basePath + pageLocation;
}
} else {
var beginUrl = window.location.href.split('?')[0];
var queryStr = window.location.search.substring(1);
var regEx = new RegExp('&?' + param + '=[^&]*');
// remove any lang field values so it doesn't duplicate it in the query string
queryStr = queryStr.replace(regEx, '');
queryStr += '&' + param + '=' + lang;
var url = beginUrl + '?' + queryStr;
}
window.location = url;
return false;
});
$('#__fuel_page_publish_toggle__').on('click',function(e){
var $this = this;
var elem = $('#__fuel_page_published__')
var val = (elem.val() == 'yes') ? 'no' : 'yes';
elem.val(val);
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_page_cache_toggle__').on('click',function(e){
var elem = $('#__fuel_page_cached__')
var val = (elem.val() == 'yes') ? 'no' : 'yes';
elem.val(val);
$('#__fuel_edit_bar_form__').ajaxSubmit(function(){
window.location.reload();
});
return false;
});
$('#__fuel_page_others__').on('change',function(){
window.location = basePath + $(this).val();
});
var hideFuelBar = function(animate){
var elem = $('#__fuel_page_toolbar_toggle__');
var exposedWidth = 0;
$('.__fuel__ .exposed').each(function(i){
exposedWidth += $(this).innerWidth();
});
var barHideX = $('#__fuel_edit_bar__').width() - (exposedWidth + 1);
if (animate){
$("#__fuel_edit_bar__").animate({ right: '-' + barHideX + 'px'}, 500);
} else {
$("#__fuel_edit_bar__").css({ right: '-' + barHideX + 'px'});
}
fuelBarOn = false;
elem.parent('li').removeClass('active');
$.supercookie('fuel_bar', 'show_fuel_bar', '0', {path: cookiePath});
}
var showFuelBar = function(animate){
var elem = $('#__fuel_page_toolbar_toggle__');
if (animate){
$("#__fuel_edit_bar__").show().animate({ right: '0px'}, 500);
} else {
$("#__fuel_edit_bar__").show().css({ right: '0px'});
}
$('.__fuel_edit_bar__').width();
fuelBarOn = true;
elem.parent('li').addClass('active');
$.supercookie('fuel_bar', 'show_fuel_bar', '1', {path: cookiePath});
}
$('#__fuel_page_toolbar_toggle__').on('click',function(){
toggleFuelBar(fuelBarOn, true);
return false;
});
var toggleFuelBar = function(shown, animate){
if (shown){
hideFuelBar(animate);
} else {
showFuelBar(animate);
}
}
// change to negative so it will toggle correctly
$("#__fuel_edit_bar__").show();
toggleFuelBar(!fuelBarOn, false);
toggleEditors(!editorsOn, false);
}
init();
});
})(jQuery);
